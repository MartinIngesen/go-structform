import:
  - unfold_templates.yml

main: |
  package gotype

  import "github.com/urso/go-structform"

  {{/* define types */}}
  {{ invoke "makeTypeWithName" "name" "Ifc" "type" "interface{}" "makeSubObject" "unfoldIfcStartSubMap" }}
  {{ template "makeType" "bool" }}
  {{ template "makeType" "string" }}
  {{ range .numTypes }}
    {{ template "makeType" . }}
  {{ end }}

  {{/* create value visitor callbacks */}}
  {{ invoke "onIfcFns" "name" "unfolderMapIfc" "fn" "put" }}
  {{ invoke "onBoolFns" "name" "unfolderMapBool" "fn" "put" }}
  {{ invoke "onStringFns" "name" "unfolderMapString" "fn" "put" }}
  {{ range .numTypes }}
    {{ $type := . }}
    {{ $name := capitalize $type | printf "unfolderMap%v" }}
    {{ invoke "onNumberFns" "name" $name "type" $type "fn" "put" }}
  {{ end }}

  func unfoldIfcStartSubMap(ctx *unfoldCtx, l int, baseType structform.BaseType) error {
    tmp := makeMapPtr(ctx, l, baseType)
    if !ctx.trySetGotypeTarget(tmp) {
      // use reflection
      v := reflect.ValueOf(tmp)
      ctx.ptr.push(unsafe.Pointer(v.Pointer()))
      ctx.value.push(v.Elem())
      ctx.state.push(unfoldMapState)
      ctx.detail.push(unfoldWaitStart)
      ctx.unfolder.push(newUnfolderRefl())
    } else {
      // duplicate pointer, so we can assign after child-object is finished
      ctx.ptr.push(ctx.ptr.current)
    }

    ctx.baseType.push(baseType)
    return ctx.unfolder.current.OnObjectStart(ctx, l, baseType)
  }

  func unfoldIfcFinishSubMap(ctx *unfoldCtx) (interface{}, error) {
    child := ctx.ptr.pop()
    bt := ctx.baseType.pop()
    switch bt {
    {{ range $bt, $gt := data.mapTypes }}
    case structform.{{ $bt }}:
      return *(*map[string]{{ $gt }})(child), nil
    {{ end }}
    default:
      fmt.Println("base type: ", bt)
      return nil, errTODO()
    }
  }

  func makeMapPtr(ctx *unfoldCtx, l int, bt structform.BaseType) interface{} {
    switch bt {
    {{ range $bt, $gt := data.mapTypes }}
    case structform.{{ $bt }}:
      return new(map[string]{{ $gt }})
    {{ end }}
    default:
      panic("invalid type code")
      return nil
    }
  }

templates.makeTypeWithName: |
  {{ $type := .type }}
  {{ $name := capitalize .name | printf "unfolderMap%v" }}
  {{ $mapType := $type | printf "map[string]%v" }}

  {{ invoke "makeUnfoldType" "name" $name "type" $mapType }}

  func (u *{{ $name }} ) OnObjectStart(ctx *unfoldCtx, l int, baseType structform.BaseType) error {
    // TODO: validate baseType

    dtl := &ctx.detail
    switch dtl.current {
    case unfoldWaitStart:
      dtl.current = unfoldWaitKey
    case unfoldWaitKey:
      return errExpectedObjectKey
    default:
      {{ if .makeSubObject }}
      return {{ .makeSubObject }}(ctx, l, baseType)
      {{ else }}
        return errUnsupported
      {{ end }}
    }

    return nil
  }

  func (u *{{ $name }} ) OnObjectFinished(ctx *unfoldCtx) error {
    dtl := &ctx.detail
    if dtl.current != unfoldWaitKey {
      return errExpectedObjectKey
    }

    dtl.pop()
    ctx.ptr.pop()
    ctx.unfolder.pop()
    return nil
  }

  func (u *{{ $name }} ) OnKey(ctx *unfoldCtx, key string) error {
    dtl := &ctx.detail

    if dtl.current != unfoldWaitKey {
      return errUnexpectedObjectKey
    }

    ctx.key.push(key)
    dtl.current = unfoldWaitElem
    return nil
  }

  func (u *{{ $name }} ) ptr(ctx *unfoldCtx) *map[string]{{ $type }} {
    return (*map[string]{{ $type }})(ctx.ptr.current)
  }

  func (u *{{ $name }} ) put(ctx *unfoldCtx, v {{ $type }}) error {
    dtl := &ctx.detail

    if dtl.current != unfoldWaitElem {
      return errExpectedObjectKey
    }

    to := u.ptr(ctx)
    if *to == nil {
      *to = map[string]{{ $type }}{}
    }
    (*to)[ctx.key.pop()] = v
    dtl.current = unfoldWaitKey
    return nil
  }
